<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head><link rel="canonical" href="https://paritytech.github.io/polkadot-sdk/book/node/backing/statement-distribution.html"><meta http-equiv="refresh" content="0;URL='https://paritytech.github.io/polkadot-sdk/book/node/backing/statement-distribution.html'">
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Statement Distribution - The Polkadot Parachain Host Implementers&#x27; Guide</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../last-changed.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Preamble</a></li><li class="chapter-item expanded "><a href="../../whence-parachains.html"><strong aria-hidden="true">1.</strong> Whence Parachains</a></li><li class="chapter-item expanded "><a href="../../protocol-overview.html"><strong aria-hidden="true">2.</strong> Protocol Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../protocol-approval.html"><strong aria-hidden="true">2.1.</strong> Approval Process</a></li><li class="chapter-item expanded "><a href="../../protocol-disputes.html"><strong aria-hidden="true">2.2.</strong> Disputes Process</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../disputes-flow.html"><strong aria-hidden="true">2.2.1.</strong> Dispute Flow</a></li></ol></li><li class="chapter-item expanded "><a href="../../protocol-chain-selection.html"><strong aria-hidden="true">2.3.</strong> Chain Selection and Finalization</a></li></ol></li><li class="chapter-item expanded "><a href="../../architecture.html"><strong aria-hidden="true">3.</strong> Architecture Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../messaging.html"><strong aria-hidden="true">3.1.</strong> Messaging Overview</a></li><li class="chapter-item expanded "><a href="../../pvf-prechecking.html"><strong aria-hidden="true">3.2.</strong> PVF Pre-checking</a></li></ol></li><li class="chapter-item expanded "><a href="../../runtime/index.html"><strong aria-hidden="true">4.</strong> Runtime Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../runtime/initializer.html"><strong aria-hidden="true">4.1.</strong> Initializer Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/configuration.html"><strong aria-hidden="true">4.2.</strong> Configuration Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/shared.html"><strong aria-hidden="true">4.3.</strong> Shared Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/disputes.html"><strong aria-hidden="true">4.4.</strong> Disputes Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/paras.html"><strong aria-hidden="true">4.5.</strong> Paras Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/scheduler.html"><strong aria-hidden="true">4.6.</strong> Scheduler Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/inclusion.html"><strong aria-hidden="true">4.7.</strong> Inclusion Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/parainherent.html"><strong aria-hidden="true">4.8.</strong> ParaInherent Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/dmp.html"><strong aria-hidden="true">4.9.</strong> DMP Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/hrmp.html"><strong aria-hidden="true">4.10.</strong> HRMP Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/session_info.html"><strong aria-hidden="true">4.11.</strong> Session Info Pallet</a></li></ol></li><li class="chapter-item expanded "><a href="../../runtime-api/index.html"><strong aria-hidden="true">5.</strong> Runtime APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../runtime-api/validators.html"><strong aria-hidden="true">5.1.</strong> Validators</a></li><li class="chapter-item expanded "><a href="../../runtime-api/validator-groups.html"><strong aria-hidden="true">5.2.</strong> Validator Groups</a></li><li class="chapter-item expanded "><a href="../../runtime-api/availability-cores.html"><strong aria-hidden="true">5.3.</strong> Availability Cores</a></li><li class="chapter-item expanded "><a href="../../runtime-api/persisted-validation-data.html"><strong aria-hidden="true">5.4.</strong> Persisted Validation Data</a></li><li class="chapter-item expanded "><a href="../../runtime-api/session-index.html"><strong aria-hidden="true">5.5.</strong> Session Index</a></li><li class="chapter-item expanded "><a href="../../runtime-api/validation-code.html"><strong aria-hidden="true">5.6.</strong> Validation Code</a></li><li class="chapter-item expanded "><a href="../../runtime-api/candidate-pending-availability.html"><strong aria-hidden="true">5.7.</strong> Candidate Pending Availability</a></li><li class="chapter-item expanded "><a href="../../runtime-api/candidate-events.html"><strong aria-hidden="true">5.8.</strong> Candidate Events</a></li><li class="chapter-item expanded "><a href="../../runtime-api/disputes-info.html"><strong aria-hidden="true">5.9.</strong> Disputes Info</a></li><li class="chapter-item expanded "><a href="../../runtime-api/candidates-included.html"><strong aria-hidden="true">5.10.</strong> Candidates Included</a></li><li class="chapter-item expanded "><a href="../../runtime-api/pvf-prechecking.html"><strong aria-hidden="true">5.11.</strong> PVF Pre-checking</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/index.html"><strong aria-hidden="true">6.</strong> Node Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/subsystems-and-jobs.html"><strong aria-hidden="true">6.1.</strong> Subsystems and Jobs</a></li><li class="chapter-item expanded "><a href="../../node/overseer.html"><strong aria-hidden="true">6.2.</strong> Overseer</a></li><li class="chapter-item expanded "><a href="../../node/grandpa-voting-rule.html"><strong aria-hidden="true">6.3.</strong> GRANDPA Voting Rule</a></li><li class="chapter-item expanded "><a href="../../node/collators/index.html"><strong aria-hidden="true">6.4.</strong> Collator Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/collators/collation-generation.html"><strong aria-hidden="true">6.4.1.</strong> Collation Generation</a></li><li class="chapter-item expanded "><a href="../../node/collators/collator-protocol.html"><strong aria-hidden="true">6.4.2.</strong> Collator Protocol</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/backing/index.html"><strong aria-hidden="true">6.5.</strong> Backing Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/backing/candidate-backing.html"><strong aria-hidden="true">6.5.1.</strong> Candidate Backing</a></li><li class="chapter-item expanded "><a href="../../node/backing/prospective-parachains.html"><strong aria-hidden="true">6.5.2.</strong> Prospective Parachains</a></li><li class="chapter-item expanded "><a href="../../node/backing/statement-distribution.html" class="active"><strong aria-hidden="true">6.5.3.</strong> Statement Distribution</a></li><li class="chapter-item expanded "><a href="../../node/backing/statement-distribution-legacy.html"><strong aria-hidden="true">6.5.4.</strong> Statement Distribution (Legacy)</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/availability/index.html"><strong aria-hidden="true">6.6.</strong> Availability Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/availability/availability-distribution.html"><strong aria-hidden="true">6.6.1.</strong> Availability Distribution</a></li><li class="chapter-item expanded "><a href="../../node/availability/availability-recovery.html"><strong aria-hidden="true">6.6.2.</strong> Availability Recovery</a></li><li class="chapter-item expanded "><a href="../../node/availability/bitfield-distribution.html"><strong aria-hidden="true">6.6.3.</strong> Bitfield Distribution</a></li><li class="chapter-item expanded "><a href="../../node/availability/bitfield-signing.html"><strong aria-hidden="true">6.6.4.</strong> Bitfield Signing</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/approval/index.html"><strong aria-hidden="true">6.7.</strong> Approval Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/approval/approval-voting.html"><strong aria-hidden="true">6.7.1.</strong> Approval Voting</a></li><li class="chapter-item expanded "><a href="../../node/approval/approval-distribution.html"><strong aria-hidden="true">6.7.2.</strong> Approval Distribution</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/disputes/index.html"><strong aria-hidden="true">6.8.</strong> Disputes Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/disputes/dispute-coordinator.html"><strong aria-hidden="true">6.8.1.</strong> Dispute Coordinator</a></li><li class="chapter-item expanded "><a href="../../node/disputes/dispute-distribution.html"><strong aria-hidden="true">6.8.2.</strong> Dispute Distribution</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/utility/index.html"><strong aria-hidden="true">6.9.</strong> Utility Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/utility/availability-store.html"><strong aria-hidden="true">6.9.1.</strong> Availability Store</a></li><li class="chapter-item expanded "><a href="../../node/utility/candidate-validation.html"><strong aria-hidden="true">6.9.2.</strong> Candidate Validation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/utility/pvf-host-and-workers.html"><strong aria-hidden="true">6.9.2.1.</strong> PVF Host and Workers</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/utility/provisioner.html"><strong aria-hidden="true">6.9.3.</strong> Provisioner</a></li><li class="chapter-item expanded "><a href="../../node/utility/network-bridge.html"><strong aria-hidden="true">6.9.4.</strong> Network Bridge</a></li><li class="chapter-item expanded "><a href="../../node/utility/gossip-support.html"><strong aria-hidden="true">6.9.5.</strong> Gossip Support</a></li><li class="chapter-item expanded "><a href="../../node/utility/peer-set-manager.html"><strong aria-hidden="true">6.9.6.</strong> Peer Set Manager</a></li><li class="chapter-item expanded "><a href="../../node/utility/runtime-api.html"><strong aria-hidden="true">6.9.7.</strong> Runtime API Requests</a></li><li class="chapter-item expanded "><a href="../../node/utility/chain-api.html"><strong aria-hidden="true">6.9.8.</strong> Chain API Requests</a></li><li class="chapter-item expanded "><a href="../../node/utility/chain-selection.html"><strong aria-hidden="true">6.9.9.</strong> Chain Selection Request</a></li><li class="chapter-item expanded "><a href="../../node/utility/pvf-prechecker.html"><strong aria-hidden="true">6.9.10.</strong> PVF Pre-Checking</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../types/index.html"><strong aria-hidden="true">7.</strong> Data Structures and Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/candidate.html"><strong aria-hidden="true">7.1.</strong> Candidate</a></li><li class="chapter-item expanded "><a href="../../types/backing.html"><strong aria-hidden="true">7.2.</strong> Backing</a></li><li class="chapter-item expanded "><a href="../../types/availability.html"><strong aria-hidden="true">7.3.</strong> Availability</a></li><li class="chapter-item expanded "><a href="../../types/overseer-protocol.html"><strong aria-hidden="true">7.4.</strong> Overseer and Subsystem Protocol</a></li><li class="chapter-item expanded "><a href="../../types/runtime.html"><strong aria-hidden="true">7.5.</strong> Runtime</a></li><li class="chapter-item expanded "><a href="../../types/messages.html"><strong aria-hidden="true">7.6.</strong> Messages</a></li><li class="chapter-item expanded "><a href="../../types/network.html"><strong aria-hidden="true">7.7.</strong> Network</a></li><li class="chapter-item expanded "><a href="../../types/approval.html"><strong aria-hidden="true">7.8.</strong> Approvals</a></li><li class="chapter-item expanded "><a href="../../types/disputes.html"><strong aria-hidden="true">7.9.</strong> Disputes</a></li><li class="chapter-item expanded "><a href="../../types/pvf-prechecking.html"><strong aria-hidden="true">7.10.</strong> PVF Pre-checking</a></li></ol></li><li class="chapter-item expanded "><a href="../../glossary.html">Glossary</a></li><li class="chapter-item expanded affix "><a href="../../further-reading.html">Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Polkadot Parachain Host Implementers&#x27; Guide</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/paritytech/polkadot" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="statement-distribution"><a class="header" href="#statement-distribution">Statement Distribution</a></h1>
<p>This subsystem is responsible for distributing signed statements that we have generated and forwarding statements generated by our peers. Received candidate receipts and statements are passed to the <a href="candidate-backing.html">Candidate Backing subsystem</a> to handle producing local statements. On receiving <code>StatementDistributionMessage::Share</code>, this subsystem distributes the message across the network with redundency to ensure a fast backing process.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><strong>Goal:</strong> every well-connected node is aware of every next potential parachain
block.</p>
<p>Validators can either:</p>
<ul>
<li>receive parachain block from collator, check block, and gossip statement.</li>
<li>receive statements from other validators, check the parachain block if it
originated within their own group, gossip forward statement if valid.</li>
</ul>
<p>Validators must have statements, candidates, and persisted validation from all
other validators. This is because we need to store statements from validators
who've checked the candidate on the relay chain, so we know who to hold
accountable in case of disputes. Any validator can be selected as the next
relay-chain block author, and this is not revealed in advance for security
reasons. As a result, all validators must have a up to date view of all possible
parachain candidates + backing statements that could be placed on-chain in the
next block.</p>
<p><a href="https://polkadot.network/blog/polkadot-v1-0-sharding-and-economic-security">This blog post</a>
puts it another way: &quot;Validators who aren't assigned to the parachain still
listen for the attestations [statements] because whichever validator ends up
being the author of the relay-chain block needs to bundle up attested parachain
blocks for several parachains and place them into the relay-chain block.&quot;</p>
<p>Backing-group quorum (that is, enough backing group votes) must be reached
before the block author will consider the candidate. Therefore, validators need
to consider <em>all</em> seconded candidates within their own group, because that's
what they're assigned to work on. Validators only need to consider <em>backable</em>
candidates from other groups. This informs the design of the statement
distribution protocol to have separate phases for in-group and out-group
distribution, respectively called &quot;cluster&quot; and &quot;grid&quot; mode (see below).</p>
<h3 id="with-async-backing"><a class="header" href="#with-async-backing">With Async Backing</a></h3>
<p>Asynchronous backing changes the runtime to accept parachain candidates from a
certain allowed range of historic relay-parents. These candidates must be backed
by the group assigned to the parachain as-of their corresponding relay parents.</p>
<h2 id="protocol"><a class="header" href="#protocol">Protocol</a></h2>
<p>To address the concern of dealing with large numbers of spam candidates or
statements, the overall design approach is to combine a focused &quot;clustering&quot;
protocol for legitimate fresh candidates with a broad-distribution &quot;grid&quot;
protocol to quickly get backed candidates into the hands of many validators.
Validators do not eagerly send each other heavy <code>CommittedCandidateReceipt</code>,
but instead request these lazily through request/response protocols.</p>
<p>A high-level description of the protocol follows:</p>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p>Nodes can send each other a few kinds of messages: <code>Statement</code>,
<code>BackedCandidateManifest</code>, <code>BackedCandidateAcknowledgement</code>.</p>
<ul>
<li><code>Statement</code> messages contain only a signed compact statement, without full
candidate info.</li>
<li><code>BackedCandidateManifest</code> messages advertise a description of a backed
candidate and stored statements.</li>
<li><code>BackedCandidateAcknowledgement</code> messages acknowledge that a backed candidate
is fully known.</li>
</ul>
<h3 id="requestresponse-protocol"><a class="header" href="#requestresponse-protocol">Request/response protocol</a></h3>
<p>Nodes can request the full <code>CommittedCandidateReceipt</code> and
<code>PersistedValidationData</code>, along with statements, over a request/response
protocol. This is the <code>AttestedCandidateRequest</code>; the response is
<code>AttestedCandidateResponse</code>.</p>
<h3 id="importability-and-the-hypothetical-frontier"><a class="header" href="#importability-and-the-hypothetical-frontier">Importability and the Hypothetical Frontier</a></h3>
<p>The <strong>prospective parachains</strong> subsystem maintains prospective &quot;fragment trees&quot;
which can be used to determine whether a particular parachain candidate could
possibly be included in the future. Candidates which either are within a
fragment tree or <em>would be</em> part of a fragment tree if accepted are said to be
in the &quot;hypothetical frontier&quot;.</p>
<p>The <strong>statement-distribution</strong> subsystem keeps track of all candidates, and
updates its knowledge of the hypothetical frontier based on events such as new
relay parents, new confirmed candidates, and newly backed candidates.</p>
<p>We only consider statements as &quot;importable&quot; when the corresponding candidate is
part of the hypothetical frontier, and only send &quot;importable&quot; statements to the
backing subsystem itself.</p>
<h3 id="cluster-mode"><a class="header" href="#cluster-mode">Cluster Mode</a></h3>
<ul>
<li>Validator nodes are partitioned into groups (with some exceptions), and
validators within a group at a relay-parent can send each other <code>Statement</code>
messages for any candidates within that group and based on that relay-parent.</li>
<li>This is referred to as the &quot;cluster&quot; mode.
<ul>
<li>Right now these are the same as backing groups, though &quot;cluster&quot;
specifically refers to the set of nodes communicating with each other in the
first phase of distribution.</li>
</ul>
</li>
<li><code>Seconded</code> statements must be sent before <code>Valid</code> statements.</li>
<li><code>Seconded</code> statements may only be sent to other members of the group when the
candidate is fully known by the local validator.
<ul>
<li>&quot;Fully known&quot; means the validator has the full <code>CommittedCandidateReceipt</code>
and <code>PersistedValidationData</code>, which it receives on request from other
validators or from a collator.</li>
<li>The reason for this is that sending a statement (which is always a
<code>CompactStatement</code> carrying nothing but a hash and signature) to the
cluster, is also a signal that the sending node is available to request the
candidate from.</li>
<li>This makes the protocol easier to reason about, while also reducing network
messages about candidates that don't really exist.</li>
</ul>
</li>
<li>Validators in a cluster receiving messages about unknown candidates request
the candidate (and statements) from other cluster members which have it.</li>
<li>Spam considerations
<ul>
<li>The maximum depth of candidates allowed in asynchronous backing determines
the maximum amount of <code>Seconded</code> statements originating from a validator V
which each validator in a cluster may send to others. This bounds the number
of candidates.</li>
<li>There is a small number of validators in each group, which further limits
the amount of candidates.</li>
</ul>
</li>
<li>We accept candidates which don't fit in the fragment trees of any relay
parents.
<ul>
<li>&quot;Accept&quot; means &quot;attempt to request and store in memory until useful or
expired&quot;.</li>
<li>We listen to prospective parachains subsystem to learn of new additions to
the fragment trees.</li>
<li>Use this to attempt to import the candidate later.</li>
</ul>
</li>
</ul>
<h3 id="grid-mode"><a class="header" href="#grid-mode">Grid Mode</a></h3>
<ul>
<li>Every consensus session provides randomness and a fixed validator set, which
is used to build a redundant grid topology.
<ul>
<li>It's redundant in the sense that there are 2 paths from every node to every
other node. See &quot;Grid Topology&quot; section for more details.</li>
</ul>
</li>
<li>This grid topology is used to create a sending path from each validator group
to every validator.</li>
<li>When a node observes a candidate as backed, it sends a
<code>BackedCandidateManifest</code> to their &quot;receiving&quot; nodes.</li>
<li>If receiving nodes don't yet know the candidate, they request it.</li>
<li>Once they know the candidate, they respond with a
<code>BackedCandidateAcknowledgement</code>.</li>
<li>Once two nodes perform a manifest/acknowledgement exchange, they can send
<code>Statement</code> messages directly to each other for any new statements they might
need.
<ul>
<li>This limits the amount of statements we'd have to deal with w.r.t.
candidates that don't really exist. See &quot;Manifest Exchange&quot; section.</li>
</ul>
</li>
<li>There are limitations on the number of candidates that can be advertised by
each peer, similar to those in the cluster. Validators do not request
candidates which exceed these limitations.</li>
<li>Validators request candidates as soon as they are advertised, but do not
import the statements until the candidate is part of the hypothetical
frontier, and do not re-advertise or acknowledge until the candidate is
considered both backable and part of the hypothetical frontier.</li>
<li>Note that requesting is not an implicit acknowledgement, and an explicit
acknowledgement must be sent upon receipt.</li>
</ul>
<h2 id="messages-1"><a class="header" href="#messages-1">Messages</a></h2>
<h3 id="incoming"><a class="header" href="#incoming">Incoming</a></h3>
<ul>
<li><code>ActiveLeaves</code>
<ul>
<li>Notification of a change in the set of active leaves.</li>
</ul>
</li>
<li><code>StatementDistributionMessage::Share</code>
<ul>
<li>Notification of a locally-originating statement. That is, this statement
comes from our node and should be distributed to other nodes.</li>
<li>Sent by the Backing Subsystem after it successfully imports a
locally-originating statement.</li>
</ul>
</li>
<li><code>StatementDistributionMessage::Backed</code>
<ul>
<li>Notification of a candidate being backed (received enough validity votes
from the backing group).</li>
<li>Sent by the Backing Subsystem after it successfully imports a statement for
the first time and after sending ~Share~.</li>
</ul>
</li>
<li><code>StatementDistributionMessage::NetworkBridgeUpdate</code>
<ul>
<li>See next section.</li>
</ul>
</li>
</ul>
<h4 id="network-bridge-events"><a class="header" href="#network-bridge-events">Network bridge events</a></h4>
<ul>
<li>v1 compatibility
<ul>
<li>Messages for the v1 protocol are routed to the legacy statement
distribution.</li>
</ul>
</li>
<li><code>Statement</code>
<ul>
<li>Notification of a signed statement.</li>
<li>Sent by a peer's Statement Distribution subsystem when circulating
statements.</li>
</ul>
</li>
<li><code>BackedCandidateManifest</code>
<ul>
<li>Notification of a backed candidate being known by the sending node.</li>
<li>For the candidate being requested by the receiving node if needed.</li>
<li>Announcement.</li>
<li>Sent by a peer's Statement Distribution subsystem.</li>
</ul>
</li>
<li><code>BackedCandidateKnown</code>
<ul>
<li>Notification of a backed candidate being known by the sending node.</li>
<li>For informing a receiving node which already has the candidate.</li>
<li>Acknowledgement.</li>
<li>Sent by a peer's Statement Distribution subsystem.</li>
</ul>
</li>
</ul>
<h3 id="outgoing"><a class="header" href="#outgoing">Outgoing</a></h3>
<ul>
<li><code>NetworkBridgeTxMessage::SendValidationMessages</code>
<ul>
<li>Sends a peer all pending messages / acknowledgements / statements for a
relay parent, either through the cluster or the grid.</li>
</ul>
</li>
<li><code>NetworkBridgeTxMessage::SendValidationMessage</code>
<ul>
<li>Circulates a compact statement to all peers who need it, either through the
cluster or the grid.</li>
</ul>
</li>
<li><code>NetworkBridgeTxMessage::ReportPeer</code>
<ul>
<li>Reports a peer (either good or bad).</li>
</ul>
</li>
<li><code>CandidateBackingMessage::Statement</code>
<ul>
<li>Note a validator's statement about a particular candidate.</li>
</ul>
</li>
<li><code>ProspectiveParachainsMessage::GetHypotheticalFrontier</code>
<ul>
<li>Gets the hypothetical frontier membership of candidates under active leaves'
fragment trees.</li>
</ul>
</li>
<li><code>NetworkBridgeTxMessage::SendRequests</code>
<ul>
<li>Sends requests, initiating the request/response protocol.</li>
</ul>
</li>
</ul>
<h2 id="requestresponse"><a class="header" href="#requestresponse">Request/Response</a></h2>
<p>We also have a request/response protocol because validators do not eagerly send
each other heavy <code>CommittedCandidateReceipt</code>, but instead need to request these
lazily.</p>
<h3 id="protocol-1"><a class="header" href="#protocol-1">Protocol</a></h3>
<ol>
<li>
<p>Requesting Validator</p>
<ul>
<li>Requests are queued up with <code>RequestManager::get_or_insert</code>.
<ul>
<li>Done as needed, when handling incoming manifests/statements.</li>
</ul>
</li>
<li><code>RequestManager::dispatch_requests</code> sends any queued-up requests.
<ul>
<li>Calls <code>RequestManager::next_request</code> to completion.
<ul>
<li>Creates the <code>OutgoingRequest</code>, saves the receiver in
<code>RequestManager::pending_responses</code>.</li>
</ul>
</li>
<li>Does nothing if we have more responses pending than the limit of parallel
requests.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Peer</p>
<ul>
<li>Requests come in on a peer on the <code>IncomingRequestReceiver</code>.
<ul>
<li>Runs in a background responder task which feeds requests to <code>answer_request</code>
through <code>MuxedMessage</code>.</li>
<li>This responder task has a limit on the number of parallel requests.</li>
</ul>
</li>
<li><code>answer_request</code> on the peer takes the request and sends a response.
<ul>
<li>Does this using the response sender on the request.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Requesting Validator</p>
<ul>
<li><code>receive_response</code> on the original validator yields a response.
<ul>
<li>Response was sent on the request's response sender.</li>
<li>Uses <code>RequestManager::await_incoming</code> to await on pending responses in an
unordered fashion.</li>
<li>Runs on the <code>MuxedMessage</code> receiver.</li>
</ul>
</li>
<li><code>handle_response</code> handles the response.</li>
</ul>
</li>
</ol>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<ul>
<li><code>dispatch_requests</code>
<ul>
<li>Dispatches pending requests for candidate data &amp; statements.</li>
</ul>
</li>
<li><code>answer_request</code>
<ul>
<li>Answers an incoming request for a candidate.</li>
<li>Takes an incoming <code>AttestedCandidateRequest</code>.</li>
</ul>
</li>
<li><code>receive_response</code>
<ul>
<li>Wait on the next incoming response.</li>
<li>If there are no requests pending, this future never resolves.</li>
<li>Returns <code>UnhandledResponse</code></li>
</ul>
</li>
<li><code>handle_response</code>
<ul>
<li>Handles an incoming response.</li>
<li>Takes <code>UnhandledResponse</code></li>
</ul>
</li>
</ul>
<h2 id="manifests"><a class="header" href="#manifests">Manifests</a></h2>
<p>A manifest is a message about a known backed candidate, along with a description
of the statements backing it. It can be one of two kinds:</p>
<ul>
<li><code>Full</code>: Contains information about the candidate and should be sent to peers
who may not have the candidate yet. This is also called an <code>Announcement</code>.</li>
<li><code>Acknowledgement</code>: Omits information implicit in the candidate, and should be
sent to peers which are guaranteed to have the candidate already.</li>
</ul>
<h3 id="manifest-exchange"><a class="header" href="#manifest-exchange">Manifest Exchange</a></h3>
<p>Manifest exchange is when a receiving node received a <code>Full</code> manifest and
replied with an <code>Acknowledgement</code>. It indicates that both nodes know the
candidate as valid and backed. This allows the nodes to send <code>Statement</code>
messages directly to each other for any new statements.</p>
<p>Why? This limits the amount of statements we'd have to deal with w.r.t.
candidates that don't really exist. Limiting out-of-group statement distribution
between peers to only candidates that both peers agree are backed and exist
ensures we only have to store statements about real candidates.</p>
<p>In practice, manifest exchange means that one of three things have happened:</p>
<ul>
<li>They announced, we acknowledged.</li>
<li>We announced, they acknowledged.</li>
<li>We announced, they announced.</li>
</ul>
<p>Concerning the last case, note that it is possible for two nodes to have each
other in their sending set. Consider:</p>
<pre><code>1 2
3 4
</code></pre>
<p>If validators 2 and 4 are in group B, then there is a path <code>2-&gt;1-&gt;3</code> and
<code>4-&gt;3-&gt;1</code>. Therefore, 1 and 3 might send each other manifests for the same
candidate at the same time, without having seen the other's yet. This also
counts as a manifest exchange, but is only allowed to occur in this way.</p>
<p>After the exchange is complete, we update pending statements. Pending statements
are those we know locally that the remote node does not.</p>
<h4 id="alternative-paths-through-the-topology"><a class="header" href="#alternative-paths-through-the-topology">Alternative Paths Through The Topology</a></h4>
<p>Nodes should send a <code>BackedCandidateAcknowledgement(CandidateHash, StatementFilter)</code> notification to any peer which has sent a manifest, and the
candidate has been acquired by other means. This keeps alternative paths through
the topology open, which allows nodes to receive additional statements that come
later, but not after the candidate has been posted on-chain.</p>
<p>This is mostly about the limitation that the runtime has no way for block
authors to post statements that come after the parablock is posted on-chain and
ensure those validators still get rewarded. Technically, we only need enough
statements to back the candidate and the manifest + request will provide that.
But more statements might come shortly afterwards, and we want those to end up
on-chain as well to ensure all validators in the group are rewarded.</p>
<p>For clarity, here is the full timeline:</p>
<ol>
<li>candidate seconded</li>
<li>backable in cluster</li>
<li>distributed along grid</li>
<li>latecomers issue statements</li>
<li>candidate posted on chain</li>
<li>really latecomers issue statements</li>
</ol>
<h2 id="cluster-module"><a class="header" href="#cluster-module">Cluster Module</a></h2>
<p>The cluster module provides direct distribution of unbacked candidates within a
group. By utilizing this initial phase of propagating only within
clusters/groups, we bound the number of <code>Seconded</code> messages per validator per
relay-parent, helping us prevent spam. Validators can try to circumvent this,
but they would only consume a few KB of memory and it is trivially slashable on
chain.</p>
<p>The cluster module determines whether to accept/reject messages from other
validators in the same group. It keeps track of what we have sent to other
validators in the group, and pending statements. For the full protocol, see
&quot;Protocol&quot;.</p>
<h2 id="grid-module"><a class="header" href="#grid-module">Grid Module</a></h2>
<p>The grid module provides distribution of backed candidates and late statements
outside the backing group. For the full protocol, see the &quot;Protocol&quot; section.</p>
<h3 id="grid-topology"><a class="header" href="#grid-topology">Grid Topology</a></h3>
<p>For distributing outside our cluster (aka backing group) we use a 2D grid 
topology. This limits the amount of peers we send messages to, and handles 
view updates.</p>
<p>The basic operation of the grid topology is that:</p>
<ul>
<li>A validator producing a message sends it to its row-neighbors and its
column-neighbors.</li>
<li>A validator receiving a message originating from one of its row-neighbors
sends it to its column-neighbors.</li>
<li>A validator receiving a message originating from one of its column-neighbors
sends it to its row-neighbors.</li>
</ul>
<p>This grid approach defines 2 unique paths for every validator to reach every
other validator in at most 2 hops, providing redundancy.</p>
<p>Propagation follows these rules:</p>
<ul>
<li>Each node has a receiving set and a sending set. These are different for each
group. That is, if a node receives a candidate from group A, it checks if it
is allowed to receive from that node for candidates from group A.</li>
<li>For groups that we are in, receive from nobody and send to our X/Y peers.</li>
<li>For groups that we are not part of:
<ul>
<li>We receive from any validator in the group we share a slice with and send to
the corresponding X/Y slice in the other dimension.</li>
<li>For any validators we don't share a slice with, we receive from the nodes
which share a slice with them.</li>
</ul>
</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>For size 11, the matrix would be:</p>
<pre><code>0  1  2
3  4  5
6  7  8
9 10
</code></pre>
<p>e.g. for index 10, the neighbors would be 1, 4, 7, 9 -- these are the nodes we
could directly communicate with (e.g. either send to or receive from).</p>
<p>Now, which of these neighbors can 10 receive from? Recall that the
sending/receiving sets for 10 would be different for different groups. Here are
some hypothetical scenarios:</p>
<ul>
<li><strong>Scenario 1:</strong> 9 belongs to group A but not 10. Here, 10 can directly receive
candidates from group A from 9. 10 would propagate them to the nodes in {1, 4,
7} that are not in A.</li>
<li><strong>Scenario 2:</strong> 6 is in group A instead of 9, and 7 is not in group A. 10 can
receive group A messages from 7 or 9. 10 will try to relay these messages, but
7 and 9 together should have already propagated the message to all x/y 
peers of 10. If so, then 10 will just receive acknowledgements in reply rather 
than requests.</li>
<li><strong>Scenario 3:</strong> 10 itself is in group A. 10 would not receive candidates from
this group from any other nodes through the grid. It would itself send such
candidates to all its neighbors that are not in A.</li>
</ul>
<h3 id="seconding-limit"><a class="header" href="#seconding-limit">Seconding Limit</a></h3>
<p>The seconding limit is a per-validator limit. Before asynchronous backing, we
had a rule that every validator was only allowed to second one candidate per
relay parent. With asynchronous backing, we have a 'maximum depth' which makes
it possible to second multiple candidates per relay parent. The seconding limit
is set to <code>max depth + 1</code> to set an upper bound on candidates entering the
system.</p>
<h2 id="candidates-module"><a class="header" href="#candidates-module">Candidates Module</a></h2>
<p>The candidates module provides a tracker for all known candidates in the view,
whether they are confirmed or not, and how peers have advertised the candidates.
What is a confirmed candidate? It is a candidate for which we have the full
receipt and the persisted validation data. This module gets confirmed candidates
from two sources:</p>
<ul>
<li>It can be that a validator fetched a collation directly from the collator and
validated it.</li>
<li>The first time a validator gets an announcement for an unknown candidate, it
will send a request for the candidate. Upon receiving a response and
validating it (see <code>UnhandledResponse::validate_response</code>), it will mark the
candidate as confirmed.</li>
</ul>
<h2 id="requests-module"><a class="header" href="#requests-module">Requests Module</a></h2>
<p>The requests module provides a manager for pending requests for candidate data,
as well as pending responses. See &quot;Request/Response Protocol&quot; for a high-level
description of the flow. See module-docs for full details.</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<ul>
<li><strong>Acknowledgement:</strong> A partial manifest sent to a validator that already has the 
candidate to inform them that the sending node also knows the candidate. 
Concludes a manifest exchange.</li>
<li><strong>Announcement:</strong> A full manifest indicating that a backed candidate is known by 
the sending node. Initiates a manifest exchange.</li>
<li><strong>Attestation:</strong> See &quot;Statement&quot;.</li>
<li><strong>Backable vs. Backed:</strong>
<ul>
<li>Note that we sometimes use &quot;backed&quot; to refer to candidates that are
&quot;backable&quot;, but not yet backed on chain.</li>
<li><strong>Backed</strong> should technically mean that the parablock candidate and its
backing statements have been added to a relay chain block.</li>
<li><strong>Backable</strong> is when the necessary backing statements have been acquired but
those statements and the parablock candidate haven't been backed in a relay
chain block yet.</li>
</ul>
</li>
<li><strong>Fragment tree:</strong> A parachain fragment not referenced by the relay-chain.
It is a tree of prospective parachain blocks.</li>
<li><strong>Manifest:</strong> A message about a known backed candidate, along with a
description of the statements backing it. There are two kinds of manifest, 
<code>Acknowledgement</code> and <code>Announcement</code>. See &quot;Manifests&quot; section.</li>
<li><strong>Peer:</strong> Another validator that a validator is connected to.</li>
<li><strong>Request/response:</strong> A protocol used to lazily request and receive heavy
candidate data when needed.</li>
<li><strong>Reputation:</strong> Tracks reputation of peers. Applies annoyance cost and good
behavior benefits.</li>
<li><strong>Statement:</strong> Signed statements that can be made about parachain candidates.
<ul>
<li><strong>Seconded:</strong> Proposal of a parachain candidate. Implicit validity vote.</li>
<li><strong>Valid:</strong> States that a parachain candidate is valid.</li>
</ul>
</li>
<li><strong>Target:</strong> Target validator to send a statement to.</li>
<li><strong>View:</strong> Current knowledge of the chain state.
<ul>
<li><strong>Explicit view</strong> / <strong>immediate view</strong>
<ul>
<li>The view a peer has of the relay chain heads and highest finalized block.</li>
</ul>
</li>
<li><strong>Implicit view</strong>
<ul>
<li>Derived from the immediate view. Composed of active leaves and minimum
relay-parents allowed for candidates of various parachains at those
leaves.</li>
</ul>
</li>
</ul>
</li>
</ul>
<footer id="last-change">Last change: 2023-08-18, commit: <a href="https://github.com/paritytech/polkadot/commit/4b7822adeb">4b7822adeb</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../node/backing/prospective-parachains.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../node/backing/statement-distribution-legacy.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../node/backing/prospective-parachains.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../node/backing/statement-distribution-legacy.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../../mermaid.min.js"></script>
        <script type="text/javascript" src="../../mermaid-init.js"></script>


    </body>
</html>
