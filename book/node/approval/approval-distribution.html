<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head><link rel="canonical" href="https://paritytech.github.io/polkadot-sdk/book/node/approval/approval-distribution.html"><meta http-equiv="refresh" content="0;URL='https://paritytech.github.io/polkadot-sdk/book/node/approval/approval-distribution.html'">
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Approval Distribution - The Polkadot Parachain Host Implementers&#x27; Guide</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../last-changed.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Preamble</a></li><li class="chapter-item expanded "><a href="../../whence-parachains.html"><strong aria-hidden="true">1.</strong> Whence Parachains</a></li><li class="chapter-item expanded "><a href="../../protocol-overview.html"><strong aria-hidden="true">2.</strong> Protocol Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../protocol-approval.html"><strong aria-hidden="true">2.1.</strong> Approval Process</a></li><li class="chapter-item expanded "><a href="../../protocol-disputes.html"><strong aria-hidden="true">2.2.</strong> Disputes Process</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../disputes-flow.html"><strong aria-hidden="true">2.2.1.</strong> Dispute Flow</a></li></ol></li><li class="chapter-item expanded "><a href="../../protocol-chain-selection.html"><strong aria-hidden="true">2.3.</strong> Chain Selection and Finalization</a></li></ol></li><li class="chapter-item expanded "><a href="../../architecture.html"><strong aria-hidden="true">3.</strong> Architecture Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../messaging.html"><strong aria-hidden="true">3.1.</strong> Messaging Overview</a></li><li class="chapter-item expanded "><a href="../../pvf-prechecking.html"><strong aria-hidden="true">3.2.</strong> PVF Pre-checking</a></li></ol></li><li class="chapter-item expanded "><a href="../../runtime/index.html"><strong aria-hidden="true">4.</strong> Runtime Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../runtime/initializer.html"><strong aria-hidden="true">4.1.</strong> Initializer Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/configuration.html"><strong aria-hidden="true">4.2.</strong> Configuration Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/shared.html"><strong aria-hidden="true">4.3.</strong> Shared Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/disputes.html"><strong aria-hidden="true">4.4.</strong> Disputes Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/paras.html"><strong aria-hidden="true">4.5.</strong> Paras Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/scheduler.html"><strong aria-hidden="true">4.6.</strong> Scheduler Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/inclusion.html"><strong aria-hidden="true">4.7.</strong> Inclusion Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/parainherent.html"><strong aria-hidden="true">4.8.</strong> ParaInherent Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/dmp.html"><strong aria-hidden="true">4.9.</strong> DMP Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/hrmp.html"><strong aria-hidden="true">4.10.</strong> HRMP Pallet</a></li><li class="chapter-item expanded "><a href="../../runtime/session_info.html"><strong aria-hidden="true">4.11.</strong> Session Info Pallet</a></li></ol></li><li class="chapter-item expanded "><a href="../../runtime-api/index.html"><strong aria-hidden="true">5.</strong> Runtime APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../runtime-api/validators.html"><strong aria-hidden="true">5.1.</strong> Validators</a></li><li class="chapter-item expanded "><a href="../../runtime-api/validator-groups.html"><strong aria-hidden="true">5.2.</strong> Validator Groups</a></li><li class="chapter-item expanded "><a href="../../runtime-api/availability-cores.html"><strong aria-hidden="true">5.3.</strong> Availability Cores</a></li><li class="chapter-item expanded "><a href="../../runtime-api/persisted-validation-data.html"><strong aria-hidden="true">5.4.</strong> Persisted Validation Data</a></li><li class="chapter-item expanded "><a href="../../runtime-api/session-index.html"><strong aria-hidden="true">5.5.</strong> Session Index</a></li><li class="chapter-item expanded "><a href="../../runtime-api/validation-code.html"><strong aria-hidden="true">5.6.</strong> Validation Code</a></li><li class="chapter-item expanded "><a href="../../runtime-api/candidate-pending-availability.html"><strong aria-hidden="true">5.7.</strong> Candidate Pending Availability</a></li><li class="chapter-item expanded "><a href="../../runtime-api/candidate-events.html"><strong aria-hidden="true">5.8.</strong> Candidate Events</a></li><li class="chapter-item expanded "><a href="../../runtime-api/disputes-info.html"><strong aria-hidden="true">5.9.</strong> Disputes Info</a></li><li class="chapter-item expanded "><a href="../../runtime-api/candidates-included.html"><strong aria-hidden="true">5.10.</strong> Candidates Included</a></li><li class="chapter-item expanded "><a href="../../runtime-api/pvf-prechecking.html"><strong aria-hidden="true">5.11.</strong> PVF Pre-checking</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/index.html"><strong aria-hidden="true">6.</strong> Node Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/subsystems-and-jobs.html"><strong aria-hidden="true">6.1.</strong> Subsystems and Jobs</a></li><li class="chapter-item expanded "><a href="../../node/overseer.html"><strong aria-hidden="true">6.2.</strong> Overseer</a></li><li class="chapter-item expanded "><a href="../../node/grandpa-voting-rule.html"><strong aria-hidden="true">6.3.</strong> GRANDPA Voting Rule</a></li><li class="chapter-item expanded "><a href="../../node/collators/index.html"><strong aria-hidden="true">6.4.</strong> Collator Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/collators/collation-generation.html"><strong aria-hidden="true">6.4.1.</strong> Collation Generation</a></li><li class="chapter-item expanded "><a href="../../node/collators/collator-protocol.html"><strong aria-hidden="true">6.4.2.</strong> Collator Protocol</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/backing/index.html"><strong aria-hidden="true">6.5.</strong> Backing Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/backing/candidate-backing.html"><strong aria-hidden="true">6.5.1.</strong> Candidate Backing</a></li><li class="chapter-item expanded "><a href="../../node/backing/prospective-parachains.html"><strong aria-hidden="true">6.5.2.</strong> Prospective Parachains</a></li><li class="chapter-item expanded "><a href="../../node/backing/statement-distribution.html"><strong aria-hidden="true">6.5.3.</strong> Statement Distribution</a></li><li class="chapter-item expanded "><a href="../../node/backing/statement-distribution-legacy.html"><strong aria-hidden="true">6.5.4.</strong> Statement Distribution (Legacy)</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/availability/index.html"><strong aria-hidden="true">6.6.</strong> Availability Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/availability/availability-distribution.html"><strong aria-hidden="true">6.6.1.</strong> Availability Distribution</a></li><li class="chapter-item expanded "><a href="../../node/availability/availability-recovery.html"><strong aria-hidden="true">6.6.2.</strong> Availability Recovery</a></li><li class="chapter-item expanded "><a href="../../node/availability/bitfield-distribution.html"><strong aria-hidden="true">6.6.3.</strong> Bitfield Distribution</a></li><li class="chapter-item expanded "><a href="../../node/availability/bitfield-signing.html"><strong aria-hidden="true">6.6.4.</strong> Bitfield Signing</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/approval/index.html"><strong aria-hidden="true">6.7.</strong> Approval Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/approval/approval-voting.html"><strong aria-hidden="true">6.7.1.</strong> Approval Voting</a></li><li class="chapter-item expanded "><a href="../../node/approval/approval-distribution.html" class="active"><strong aria-hidden="true">6.7.2.</strong> Approval Distribution</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/disputes/index.html"><strong aria-hidden="true">6.8.</strong> Disputes Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/disputes/dispute-coordinator.html"><strong aria-hidden="true">6.8.1.</strong> Dispute Coordinator</a></li><li class="chapter-item expanded "><a href="../../node/disputes/dispute-distribution.html"><strong aria-hidden="true">6.8.2.</strong> Dispute Distribution</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/utility/index.html"><strong aria-hidden="true">6.9.</strong> Utility Subsystems</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/utility/availability-store.html"><strong aria-hidden="true">6.9.1.</strong> Availability Store</a></li><li class="chapter-item expanded "><a href="../../node/utility/candidate-validation.html"><strong aria-hidden="true">6.9.2.</strong> Candidate Validation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node/utility/pvf-host-and-workers.html"><strong aria-hidden="true">6.9.2.1.</strong> PVF Host and Workers</a></li></ol></li><li class="chapter-item expanded "><a href="../../node/utility/provisioner.html"><strong aria-hidden="true">6.9.3.</strong> Provisioner</a></li><li class="chapter-item expanded "><a href="../../node/utility/network-bridge.html"><strong aria-hidden="true">6.9.4.</strong> Network Bridge</a></li><li class="chapter-item expanded "><a href="../../node/utility/gossip-support.html"><strong aria-hidden="true">6.9.5.</strong> Gossip Support</a></li><li class="chapter-item expanded "><a href="../../node/utility/peer-set-manager.html"><strong aria-hidden="true">6.9.6.</strong> Peer Set Manager</a></li><li class="chapter-item expanded "><a href="../../node/utility/runtime-api.html"><strong aria-hidden="true">6.9.7.</strong> Runtime API Requests</a></li><li class="chapter-item expanded "><a href="../../node/utility/chain-api.html"><strong aria-hidden="true">6.9.8.</strong> Chain API Requests</a></li><li class="chapter-item expanded "><a href="../../node/utility/chain-selection.html"><strong aria-hidden="true">6.9.9.</strong> Chain Selection Request</a></li><li class="chapter-item expanded "><a href="../../node/utility/pvf-prechecker.html"><strong aria-hidden="true">6.9.10.</strong> PVF Pre-Checking</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../types/index.html"><strong aria-hidden="true">7.</strong> Data Structures and Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/candidate.html"><strong aria-hidden="true">7.1.</strong> Candidate</a></li><li class="chapter-item expanded "><a href="../../types/backing.html"><strong aria-hidden="true">7.2.</strong> Backing</a></li><li class="chapter-item expanded "><a href="../../types/availability.html"><strong aria-hidden="true">7.3.</strong> Availability</a></li><li class="chapter-item expanded "><a href="../../types/overseer-protocol.html"><strong aria-hidden="true">7.4.</strong> Overseer and Subsystem Protocol</a></li><li class="chapter-item expanded "><a href="../../types/runtime.html"><strong aria-hidden="true">7.5.</strong> Runtime</a></li><li class="chapter-item expanded "><a href="../../types/messages.html"><strong aria-hidden="true">7.6.</strong> Messages</a></li><li class="chapter-item expanded "><a href="../../types/network.html"><strong aria-hidden="true">7.7.</strong> Network</a></li><li class="chapter-item expanded "><a href="../../types/approval.html"><strong aria-hidden="true">7.8.</strong> Approvals</a></li><li class="chapter-item expanded "><a href="../../types/disputes.html"><strong aria-hidden="true">7.9.</strong> Disputes</a></li><li class="chapter-item expanded "><a href="../../types/pvf-prechecking.html"><strong aria-hidden="true">7.10.</strong> PVF Pre-checking</a></li></ol></li><li class="chapter-item expanded "><a href="../../glossary.html">Glossary</a></li><li class="chapter-item expanded affix "><a href="../../further-reading.html">Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Polkadot Parachain Host Implementers&#x27; Guide</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/paritytech/polkadot" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="approval-distribution"><a class="header" href="#approval-distribution">Approval Distribution</a></h1>
<p>A subsystem for the distribution of assignments and approvals for approval checks on candidates over the network.</p>
<p>The <a href="approval-voting.html">Approval Voting</a> subsystem is responsible for active participation in a protocol designed to select a sufficient number of validators to check each and every candidate which appears in the relay chain. Statements of participation in this checking process are divided into two kinds:</p>
<ul>
<li><strong>Assignments</strong> indicate that validators have been selected to do checking</li>
<li><strong>Approvals</strong> indicate that validators have checked and found the candidate satisfactory.</li>
</ul>
<p>The <a href="approval-voting.html">Approval Voting</a> subsystem handles all the issuing and tallying of this protocol, but this subsystem is responsible for the disbursal of statements among the validator-set.</p>
<p>The inclusion pipeline of candidates concludes after availability, and only after inclusion do candidates actually get pushed into the approval checking pipeline. As such, this protocol deals with the candidates <em>made available by</em> particular blocks, as opposed to the candidates which actually appear within those blocks, which are the candidates <em>backed by</em> those blocks. Unless stated otherwise, whenever we reference a candidate partially by block hash, we are referring to the set of candidates <em>made available by</em> those blocks.</p>
<p>We implement this protocol as a gossip protocol, and like other parachain-related gossip protocols our primary concerns are about ensuring fast message propagation while maintaining an upper bound on the number of messages any given node must store at any time.</p>
<p>Approval messages should always follow assignments, so we need to be able to discern two pieces of information based on our <a href="../../types/network.html#universal-types">View</a>:</p>
<ol>
<li>Is a particular assignment relevant under a given <code>View</code>?</li>
<li>Is a particular approval relevant to any assignment in a set?</li>
</ol>
<p>For our own local view, these two queries  must not yield false negatives. When applied to our peers' views, it is acceptable for them to yield false negatives. The reason for that is that our peers' views may be beyond ours, and we are not capable of fully evaluating them. Once we have caught up, we can check again for false negatives to continue distributing.</p>
<p>For assignments, what we need to be checking is whether we are aware of the (block, candidate) pair that the assignment references. For approvals, we need to be aware of an assignment by the same validator which references the candidate being approved.</p>
<p>However, awareness on its own of a (block, candidate) pair would imply that even ancient candidates all the way back to the genesis are relevant. We are actually not interested in anything before finality.</p>
<p>We gossip assignments along a grid topology produced by the <a href="../utility/gossip-support.html">Gossip Support Subsystem</a> and also to a few random peers. The first time we accept an assignment or approval, regardless of the source, which originates from a validator peer in a shared dimension of the grid, we propagate the message to validator peers in the unshared dimension as well as a few random peers.</p>
<p>But, in case these mechanisms don't work on their own, we need to trade bandwidth for protocol liveness by introducing aggression.</p>
<p>Aggression has 3 levels:
Aggression Level 0: The basic behaviors described above.
Aggression Level 1: The originator of a message sends to all peers. Other peers follow the rules above.
Aggression Level 2: All peers send all messages to all their row and column neighbors. This means that each validator will, on average, receive each message approximately 2*sqrt(n) times.</p>
<p>These aggression levels are chosen based on how long a block has taken to finalize: assignments and approvals related to the unfinalized block will be propagated with more aggression. In particular, it's only the earliest unfinalized blocks that aggression should be applied to, because descendants may be unfinalized only by virtue of being descendants.</p>
<h2 id="protocol"><a class="header" href="#protocol">Protocol</a></h2>
<p>Input:</p>
<ul>
<li><code>ApprovalDistributionMessage::NewBlocks</code></li>
<li><code>ApprovalDistributionMessage::DistributeAssignment</code></li>
<li><code>ApprovalDistributionMessage::DistributeApproval</code></li>
<li><code>ApprovalDistributionMessage::NetworkBridgeUpdate</code></li>
<li><code>OverseerSignal::BlockFinalized</code></li>
</ul>
<p>Output:</p>
<ul>
<li><code>ApprovalVotingMessage::CheckAndImportAssignment</code></li>
<li><code>ApprovalVotingMessage::CheckAndImportApproval</code></li>
<li><code>NetworkBridgeMessage::SendValidationMessage::ApprovalDistribution</code></li>
</ul>
<h2 id="functionality"><a class="header" href="#functionality">Functionality</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type BlockScopedCandidate = (Hash, CandidateHash);

enum PendingMessage {
  Assignment(IndirectAssignmentCert, CoreIndex),
  Approval(IndirectSignedApprovalVote),
}

/// The `State` struct is responsible for tracking the overall state of the subsystem.
///
/// It tracks metadata about our view of the unfinalized chain, which assignments and approvals we have seen, and our peers' views.
struct State {
  // These two fields are used in conjunction to construct a view over the unfinalized chain.
  blocks_by_number: BTreeMap&lt;BlockNumber, Vec&lt;Hash&gt;&gt;,
  blocks: HashMap&lt;Hash, BlockEntry&gt;,

  /// Our view updates to our peers can race with `NewBlocks` updates. We store messages received
  /// against the directly mentioned blocks in our view in this map until `NewBlocks` is received.
  ///
  /// As long as the parent is already in the `blocks` map and `NewBlocks` messages aren't delayed
  /// by more than a block length, this strategy will work well for mitigating the race. This is
  /// also a race that occurs typically on local networks.
  pending_known: HashMap&lt;Hash, Vec&lt;(PeerId, PendingMessage&gt;)&gt;&gt;,

  // Peer view data is partially stored here, and partially inline within the `BlockEntry`s
  peer_views: HashMap&lt;PeerId, View&gt;,
}

enum MessageFingerprint {
  Assigment(Hash, u32, ValidatorIndex),
  Approval(Hash, u32, ValidatorIndex),
}

struct Knowledge {
  known_messages: HashSet&lt;MessageFingerprint&gt;,
}

struct PeerKnowledge {
  /// The knowledge we've sent to the peer.
  sent: Knowledge,
  /// The knowledge we've received from the peer.
  received: Knowledge,
}

/// Information about blocks in our current view as well as whether peers know of them.
struct BlockEntry {
  // Peers who we know are aware of this block and thus, the candidates within it. This maps to their knowledge of messages.
  known_by: HashMap&lt;PeerId, PeerKnowledge&gt;,
  // The number of the block.
  number: BlockNumber,
  // The parent hash of the block.
  parent_hash: Hash,
  // Our knowledge of messages.
  knowledge: Knowledge,
  // A votes entry for each candidate.
  candidates: IndexMap&lt;CandidateHash, CandidateEntry&gt;,
}

enum ApprovalState {
  Assigned(AssignmentCert),
  Approved(AssignmentCert, ApprovalSignature),
}

/// Information about candidates in the context of a particular block they are included in. In other words,
/// multiple `CandidateEntry`s may exist for the same candidate, if it is included by multiple blocks - this is likely the case
/// when there are forks.
struct CandidateEntry {
  approvals: HashMap&lt;ValidatorIndex, ApprovalState&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="network-updates"><a class="header" href="#network-updates">Network updates</a></h3>
<h4 id="networkbridgeeventpeerconnected"><a class="header" href="#networkbridgeeventpeerconnected"><code>NetworkBridgeEvent::PeerConnected</code></a></h4>
<p>Add a blank view to the <code>peer_views</code> state.</p>
<h4 id="networkbridgeeventpeerdisconnected"><a class="header" href="#networkbridgeeventpeerdisconnected"><code>NetworkBridgeEvent::PeerDisconnected</code></a></h4>
<p>Remove the view under the associated <code>PeerId</code> from <code>State::peer_views</code>.</p>
<p>Iterate over every <code>BlockEntry</code> and remove <code>PeerId</code> from it.</p>
<h4 id="networkbridgeeventourviewchange"><a class="header" href="#networkbridgeeventourviewchange"><code>NetworkBridgeEvent::OurViewChange</code></a></h4>
<p>Remove entries in <code>pending_known</code> for all hashes not present in the view.
Ensure a vector is present in <code>pending_known</code> for each hash in the view that does not have an entry in <code>blocks</code>.</p>
<h4 id="networkbridgeeventpeerviewchange"><a class="header" href="#networkbridgeeventpeerviewchange"><code>NetworkBridgeEvent::PeerViewChange</code></a></h4>
<p>Invoke <code>unify_with_peer(peer, view)</code> to catch them up to messages we have.</p>
<p>We also need to use the <code>view.finalized_number</code> to remove the <code>PeerId</code> from any blocks that it won't be wanting information about anymore. Note that we have to be on guard for peers doing crazy stuff like jumping their <code>finalized_number</code> forward 10 trillion blocks to try and get us stuck in a loop for ages.</p>
<p>One of the safeguards we can implement is to reject view updates from peers where the new <code>finalized_number</code> is less than the previous.</p>
<p>We augment that by defining <code>constrain(x)</code> to output the x bounded by the first and last numbers in <code>state.blocks_by_number</code>.</p>
<p>From there, we can loop backwards from <code>constrain(view.finalized_number)</code> until <code>constrain(last_view.finalized_number)</code> is reached, removing the <code>PeerId</code> from all <code>BlockEntry</code>s referenced at that height. We can break the loop early if we ever exit the bound supplied by the first block in <code>state.blocks_by_number</code>.</p>
<h4 id="networkbridgeeventpeermessage"><a class="header" href="#networkbridgeeventpeermessage"><code>NetworkBridgeEvent::PeerMessage</code></a></h4>
<p>If the block hash referenced by the message exists in <code>pending_known</code>, add it to the vector of pending messages and return.</p>
<p>If the message is of type <code>ApprovalDistributionV1Message::Assignment(assignment_cert, claimed_index)</code>, then call <code>import_and_circulate_assignment(MessageSource::Peer(sender), assignment_cert, claimed_index)</code></p>
<p>If the message is of type <code>ApprovalDistributionV1Message::Approval(approval_vote)</code>, then call <code>import_and_circulate_approval(MessageSource::Peer(sender), approval_vote)</code></p>
<h3 id="subsystem-updates"><a class="header" href="#subsystem-updates">Subsystem Updates</a></h3>
<h4 id="approvaldistributionmessagenewblocks"><a class="header" href="#approvaldistributionmessagenewblocks"><code>ApprovalDistributionMessage::NewBlocks</code></a></h4>
<p>Create <code>BlockEntry</code> and <code>CandidateEntries</code> for all blocks.</p>
<p>For all entries in <code>pending_known</code>:</p>
<ul>
<li>If there is now an entry under <code>blocks</code> for the block hash, drain all messages and import with <code>import_and_circulate_assignment</code> and <code>import_and_circulate_approval</code>.</li>
</ul>
<p>For all peers:</p>
<ul>
<li>Compute <code>view_intersection</code> as the intersection of the peer's view blocks with the hashes of the new blocks.</li>
<li>Invoke <code>unify_with_peer(peer, view_intersection)</code>.</li>
</ul>
<h4 id="approvaldistributionmessagedistributeasignment"><a class="header" href="#approvaldistributionmessagedistributeasignment"><code>ApprovalDistributionMessage::DistributeAsignment</code></a></h4>
<p>Call <code>import_and_circulate_assignment</code> with <code>MessageSource::Local</code>.</p>
<h4 id="approvaldistributionmessagedistributeapproval"><a class="header" href="#approvaldistributionmessagedistributeapproval"><code>ApprovalDistributionMessage::DistributeApproval</code></a></h4>
<p>Call <code>import_and_circulate_approval</code> with <code>MessageSource::Local</code>.</p>
<h4 id="overseersignalblockfinalized"><a class="header" href="#overseersignalblockfinalized"><code>OverseerSignal::BlockFinalized</code></a></h4>
<p>Prune all lists from <code>blocks_by_number</code> with number less than or equal to <code>finalized_number</code>. Prune all the <code>BlockEntry</code>s referenced by those lists.</p>
<h3 id="utility"><a class="header" href="#utility">Utility</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MessageSource {
  Peer(PeerId),
  Local,
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="import_and_circulate_assignmentsource-messagesource-assignment-indirectassignmentcert-claimed_candidate_index-candidateindex"><a class="header" href="#import_and_circulate_assignmentsource-messagesource-assignment-indirectassignmentcert-claimed_candidate_index-candidateindex"><code>import_and_circulate_assignment(source: MessageSource, assignment: IndirectAssignmentCert, claimed_candidate_index: CandidateIndex)</code></a></h4>
<p>Imports an assignment cert referenced by block hash and candidate index. As a postcondition, if the cert is valid, it will have distributed the cert to all peers who have the block in their view, with the exclusion of the peer referenced by the <code>MessageSource</code>.</p>
<p>We maintain a few invariants:</p>
<ul>
<li>we only send an assignment to a peer after we add its fingerprint to our knowledge</li>
<li>we add a fingerprint of an assignment to our knowledge only if it's valid and hasn't been added before</li>
</ul>
<p>The algorithm is the following:</p>
<ul>
<li>Load the <code>BlockEntry</code> using <code>assignment.block_hash</code>. If it does not exist, report the source if it is <code>MessageSource::Peer</code> and return.</li>
<li>Compute a fingerprint for the <code>assignment</code> using <code>claimed_candidate_index</code>.</li>
<li>If the source is <code>MessageSource::Peer(sender)</code>:
<ul>
<li>check if <code>peer</code> appears under <code>known_by</code> and whether the fingerprint is in the knowledge of the peer. If the peer does not know the block, report for providing data out-of-view and proceed. If the peer does know the block and the <code>sent</code> knowledge contains the fingerprint, report for providing replicate data and return, otherwise, insert into the <code>received</code> knowledge and return.</li>
<li>If the message fingerprint appears under the <code>BlockEntry</code>'s <code>Knowledge</code>, give the peer a small positive reputation boost,
add the fingerprint to the peer's knowledge only if it knows about the block and return.
Note that we must do this after checking for out-of-view and if the peers knows about the block to avoid being spammed.
If we did this check earlier, a peer could provide data out-of-view repeatedly and be rewarded for it.</li>
<li>Dispatch <code>ApprovalVotingMessage::CheckAndImportAssignment(assignment)</code> and wait for the response.</li>
<li>If the result is <code>AssignmentCheckResult::Accepted</code>
<ul>
<li>If the vote was accepted but not duplicate, give the peer a positive reputation boost</li>
<li>add the fingerprint to both our and the peer's knowledge in the <code>BlockEntry</code>. Note that we only doing this after making sure we have the right fingerprint.</li>
</ul>
</li>
<li>If the result is <code>AssignmentCheckResult::AcceptedDuplicate</code>, add the fingerprint to the peer's knowledge if it knows about the block and return.</li>
<li>If the result is <code>AssignmentCheckResult::TooFarInFuture</code>, mildly punish the peer and return.</li>
<li>If the result is <code>AssignmentCheckResult::Bad</code>, punish the peer and return.</li>
</ul>
</li>
<li>If the source is <code>MessageSource::Local(CandidateIndex)</code>
<ul>
<li>check if the fingerprint appears under the <code>BlockEntry's</code> knowledge. If not, add it.</li>
</ul>
</li>
<li>Load the candidate entry for the given candidate index. It should exist unless there is a logic error in the approval voting subsystem.</li>
<li>Set the approval state for the validator index to <code>ApprovalState::Assigned</code> unless the approval state is set already. This should not happen as long as the approval voting subsystem instructs us to ignore duplicate assignments.</li>
<li>Dispatch a <code>ApprovalDistributionV1Message::Assignment(assignment, candidate_index)</code> to all peers in the <code>BlockEntry</code>'s <code>known_by</code> set, excluding the peer in the <code>source</code>, if <code>source</code> has kind <code>MessageSource::Peer</code>. Add the fingerprint of the assignment to the knowledge of each peer.</li>
</ul>
<h4 id="import_and_circulate_approvalsource-messagesource-approval-indirectsignedapprovalvote"><a class="header" href="#import_and_circulate_approvalsource-messagesource-approval-indirectsignedapprovalvote"><code>import_and_circulate_approval(source: MessageSource, approval: IndirectSignedApprovalVote)</code></a></h4>
<p>Imports an approval signature referenced by block hash and candidate index:</p>
<ul>
<li>Load the <code>BlockEntry</code> using <code>approval.block_hash</code> and the candidate entry using <code>approval.candidate_entry</code>. If either does not exist, report the source if it is <code>MessageSource::Peer</code> and return.</li>
<li>Compute a fingerprint for the approval.</li>
<li>Compute a fingerprint for the corresponding assignment. If the <code>BlockEntry</code>'s knowledge does not contain that fingerprint, then report the source if it is <code>MessageSource::Peer</code> and return. All references to a fingerprint after this refer to the approval's, not the assignment's.</li>
<li>If the source is <code>MessageSource::Peer(sender)</code>:
<ul>
<li>check if <code>peer</code> appears under <code>known_by</code> and whether the fingerprint is in the knowledge of the peer. If the peer does not know the block, report for providing data out-of-view and proceed. If the peer does know the block and the <code>sent</code> knowledge contains the fingerprint, report for providing replicate data and return, otherwise, insert into the <code>received</code> knowledge and return.</li>
<li>If the message fingerprint appears under the <code>BlockEntry</code>'s <code>Knowledge</code>, give the peer a small positive reputation boost,
add the fingerprint to the peer's knowledge only if it knows about the block and return.
Note that we must do this after checking for out-of-view to avoid being spammed. If we did this check earlier, a peer could provide data out-of-view repeatedly and be rewarded for it.</li>
<li>Dispatch <code>ApprovalVotingMessage::CheckAndImportApproval(approval)</code> and wait for the response.</li>
<li>If the result is <code>VoteCheckResult::Accepted(())</code>:
<ul>
<li>Give the peer a positive reputation boost and add the fingerprint to both our and the peer's knowledge.</li>
</ul>
</li>
<li>If the result is <code>VoteCheckResult::Bad</code>:
<ul>
<li>Report the peer and return.</li>
</ul>
</li>
</ul>
</li>
<li>Load the candidate entry for the given candidate index. It should exist unless there is a logic error in the approval voting subsystem.</li>
<li>Set the approval state for the validator index to <code>ApprovalState::Approved</code>. It should already be in the <code>Assigned</code> state as our <code>BlockEntry</code> knowledge contains a fingerprint for the assignment.</li>
<li>Dispatch a <code>ApprovalDistributionV1Message::Approval(approval)</code> to all peers in the <code>BlockEntry</code>'s <code>known_by</code> set, excluding the peer in the <code>source</code>, if <code>source</code> has kind <code>MessageSource::Peer</code>. Add the fingerprint of the assignment to the knowledge of each peer. Note that this obeys the politeness conditions:
<ul>
<li>We guarantee elsewhere that all peers within <code>known_by</code> are aware of all assignments relative to the block.</li>
<li>We've checked that this specific approval has a corresponding assignment within the <code>BlockEntry</code>.</li>
<li>Thus, all peers are aware of the assignment or have a message to them in-flight which will make them so.</li>
</ul>
</li>
</ul>
<h4 id="unify_with_peerpeer-peerid-view"><a class="header" href="#unify_with_peerpeer-peerid-view"><code>unify_with_peer(peer: PeerId, view)</code>:</a></h4>
<ol>
<li>Initialize a set <code>missing_knowledge = {}</code></li>
</ol>
<p>For each block in the view:
2. Load the <code>BlockEntry</code> for the block. If the block is unknown, or the number is less than or equal to the view's finalized number go to step 6.
3. Inspect the <code>known_by</code> set of the <code>BlockEntry</code>. If the peer already knows all assignments/approvals, go to step 6.
4. Add the peer to <code>known_by</code> and add the hash and missing knowledge of the block to <code>missing_knowledge</code>.
5. Return to step 2 with the ancestor of the block.</p>
<ol start="6">
<li>For each block in <code>missing_knowledge</code>, send all assignments and approvals for all candidates in those blocks to the peer.</li>
</ol>
<footer id="last-change">Last change: 2022-04-21, commit: <a href="https://github.com/paritytech/polkadot/commit/55bf03157f">55bf03157f</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../node/approval/approval-voting.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../node/disputes/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../node/approval/approval-voting.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../node/disputes/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../../mermaid.min.js"></script>
        <script type="text/javascript" src="../../mermaid-init.js"></script>


    </body>
</html>
