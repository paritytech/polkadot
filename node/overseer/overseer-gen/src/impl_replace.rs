//! Replace a subsystem
use proc_macro2::{Span, TokenStream};
use quote::quote;
use syn::{Ident, Result};

use super::*;

pub(crate) fn impl_replacable_subsystem(
	info: &OverseerInfo,
) -> Result<proc_macro2::TokenStream> {
	let msg = "Generated by #[overlord] derive proc-macro.";

	let span = Span::call_site();
	let overseer_name = &info.overseer_name;

	let field_ty = &info.subsystem_generic_types();
	let baggage_generic_ty = &info.baggage_generic_types();

	let baggage_name = &info.baggage_names();

	let generics = quote! {
		< Ctx, #( #baggage_generic_ty, )* #( #field_ty, )* >
	};

	let where_clause = quote! {
		where
			Ctx: SubsystemContext,
			#( #field_ty : Subsystem<Ctx>, )*
	};

	let mut additive = TokenStream::new();

	// generate an impl of `fn replace_#name`
	for SubSysField { name: replacable_item, ty: _replacable_item_ty, generic, .. } in info.subsystems.iter() {
		let keeper = info.subsystems.iter().filter(|&ssf| ssf.generic != *generic).map(|ssf| ssf.name.clone());

		let fn_name = Ident::new(&format!("replace_{}", replacable_item), span);
		// adjust the generics such that the appropriate member type is replaced

		let new = Ident::new("NEW", span);
		let modified_generics = &info.subsystems
			.iter()
			.map(|ssf| if ssf.generic != *generic { ssf.generic.clone() } else { new.clone() })
			.collect::<Vec<_>>();

		let modified_generics = quote! {
			< Ctx, #( #baggage_generic_ty, )* #( #modified_generics, )* >
		};

		let x: TokenStream = quote! {
			impl #generics #overseer_name #generics #where_clause {
				#[doc = #msg]
				pub fn #fn_name < #new > (self, replacement: #new) -> #overseer_name #modified_generics
					where
						#new: Subsystem<Ctx>,
				{
					#overseer_name :: #modified_generics {
						#replacable_item: replacement,
						#(
							#keeper: self.#keeper,
						)*
						#(
							#baggage_name: self.#baggage_name,
						)*
					}
				}
			}
		};
		additive.extend(x);
	}

	Ok(additive)
}
